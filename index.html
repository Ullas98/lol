<script>
  // year
  document.getElementById('year').textContent = new Date().getFullYear();

  const canvas = document.getElementById('bg');
  const ctx = canvas.getContext('2d');
  let w = canvas.width = innerWidth;
  let h = canvas.height = innerHeight;

  const mouse = { x: w/2, y: h/2, active: false };
  let particles = [];

  window.addEventListener('resize', () => {
    w = canvas.width = innerWidth;
    h = canvas.height = innerHeight;
    reset();
  });

  canvas.addEventListener('mousemove', e => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
    mouse.active = true;
  });

  canvas.addEventListener('mouseleave', () => mouse.active = false);

  function rand(a,b){ return Math.random()*(b-a)+a; }

  class Particle {
    constructor(){ this.reset(true); }

    reset(){
      this.x = rand(0,w);
      this.y = rand(0,h);
      this.vx = rand(-0.4,0.4);
      this.vy = rand(-0.4,0.4);
      this.r = rand(1.3,3.4);
      this.baseR = this.r;
      this.alpha = rand(0.3,0.85);
      this.hue = rand(190,260);
    }

    update(){
      if(mouse.active){
        const dx = this.x - mouse.x;
        const dy = this.y - mouse.y;
        const dist = Math.sqrt(dx*dx + dy*dy) || 0.001;

        const zone = 140;     // repel distance
        if(dist < zone){
          const force = (zone - dist) / zone;
          const push = force * 1.8;  // repulsion strength

          this.vx += (dx / dist) * push;
          this.vy += (dy / dist) * push;

          // size bump when close
          this.r = Math.min(this.baseR * 2.4, this.r + force * 1.2);
        } else {
          this.r += (this.baseR - this.r) * 0.06;
        }
      }

      this.x += this.vx;
      this.y += this.vy;

      this.vx *= 0.94;
      this.vy *= 0.94;

      // wrap edges
      if(this.x < -10) this.x = w + 10;
      if(this.x > w + 10) this.x = -10;
      if(this.y < -10) this.y = h + 10;
      if(this.y > h + 10) this.y = -10;
    }

    draw(){
      ctx.beginPath();
      ctx.fillStyle = `hsla(${this.hue},85%,60%,${this.alpha})`;
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function connect(){
    for(let i=0;i<particles.length;i++){
      for(let j=i+1;j<particles.length;j++){
        const a = particles[i], b = particles[j];
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        const d = Math.sqrt(dx*dx + dy*dy);
        if(d < 110){
          const t = 1 - d / 110;
          ctx.strokeStyle = `rgba(150,180,255,${0.05 + 0.18*t})`;
          ctx.lineWidth = t;
          ctx.beginPath();
          ctx.moveTo(a.x,a.y);
          ctx.lineTo(b.x,b.y);
          ctx.stroke();
        }
      }
    }
  }

  function reset(){
    const count = Math.round((w*h)/90000);
    particles = [];
    for(let i=0;i<count;i++) particles.push(new Particle());
  }

  reset();

  function animate(){
    ctx.clearRect(0,0,w,h);

    const g=ctx.createLinearGradient(0,0,w,h);
    g.addColorStop(0,'rgba(10,15,25,0.16)');
    g.addColorStop(1,'rgba(20,10,35,0.12)');
    ctx.fillStyle=g;
    ctx.fillRect(0,0,w,h);

    for(const p of particles){
      p.update();
      p.draw();
    }

    connect();
    requestAnimationFrame(animate);
  }

  animate();
</script>
