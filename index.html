<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ullas — links</title>
  <meta name="description" content="Profile links" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0b1220;
      --glass:rgba(15,23,42,.55);
      --text:#e6f0ff;
      --muted:#9db2d7;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family:Poppins,system-ui,sans-serif; color:var(--text); background:var(--bg); overflow:hidden;}
    canvas#bg{position:fixed; inset:0; width:100%; height:100%; display:block; z-index:-2;}
    .fog{position:fixed; inset:-40%; z-index:-1; filter: blur(60px) opacity(.65);
      background: radial-gradient(40% 30% at 20% 20%, #00d4ff22, transparent 60%),
                  radial-gradient(50% 40% at 80% 30%, #7c3aed22, transparent 65%),
                  radial-gradient(60% 50% at 50% 80%, #10b98122, transparent 70%);
      animation:fogMove 22s infinite alternate ease-in-out;
    }
    @keyframes fogMove{from{transform:translate(-2%, 1%) scale(1.05)}to{transform:translate(2%, -1%) scale(1.1)}}
    .wrap{display:grid; place-items:center; height:100%; padding:32px}
    .card{width:min(680px, 92vw); padding:28px 26px 22px; background:var(--glass); border:1px solid #ffffff12; border-radius:24px;
      box-shadow: 0 10px 40px rgba(0,0,0,.35); backdrop-filter: blur(10px);}
    .head{display:flex; align-items:center; gap:18px;}
    .title{display:flex; flex-direction:column;}
    h1{margin:0; font-size:clamp(28px, 4vw, 38px)}
    .status{display:inline-flex; align-items:center; gap:8px; border-radius:999px; padding:8px 12px; background:linear-gradient(135deg,#ffffff14,#00000010); border:1px solid #ffffff18; font-size:14px; color:#ffb4b4; margin-top:8px}
    .links{display:grid; grid-template-columns:repeat(auto-fit, minmax(220px,1fr)); gap:14px; margin-top:22px}
    .btn{display:flex; align-items:center; gap:10px; padding:14px 16px; border-radius:16px; text-decoration:none; color:var(--text); background:linear-gradient(180deg, #0f172acc, #0b1220cc); border:1px solid #ffffff1a;}
    .foot{display:flex; align-items:center; justify-content:space-between; margin-top:16px; font-size:12px}
    /* small responsive tweak so card doesn't overlap on tiny screens */
    @media (max-height:420px){
      .wrap{padding:12px}
      .card{padding:18px}
    }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>
  <div class="fog"></div>
  <main class="wrap">
    <section class="card">
      <header class="head">
        <div class="title">
          <h1>ullas</h1>
          <div class="status">
            <span>Discord: sixtytoo 1402889608336769026</span>
          </div>
        </div>
      </header>

      <div class="links">
        <a class="btn" href="https://discord.com/users/1402889608336769026" target="_blank" rel="noopener">Discord</a>
      </div>

      <div class="foot">
        <span>© <span id="year"></span> ullas</span>
      </div>
    </section>
  </main>

  <script>
    // year
    document.getElementById('year').textContent = new Date().getFullYear();

    // interactive particle background
    const canvas = document.getElementById('bg');
    const ctx = canvas.getContext('2d', { alpha: true });
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;
    const particles = [];
    const particleCount = Math.round((w * h) / 80000); // scale with screen
    const mouse = { x: w / 2, y: h / 2, r: Math.min(w,h) * 0.12, down: false };

    window.addEventListener('resize', () => {
      w = canvas.width = innerWidth;
      h = canvas.height = innerHeight;
      mouse.r = Math.min(w,h) * 0.12;
      // adjust particle count a bit
      while(particles.length < Math.round((w * h) / 80000)) particles.push(new Particle());
      while(particles.length > Math.round((w * h) / 80000)) particles.pop();
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });
    canvas.addEventListener('mouseleave', () => { mouse.x = w/2; mouse.y = h/2; });

    canvas.addEventListener('mousedown', () => mouse.down = true);
    canvas.addEventListener('mouseup', () => mouse.down = false);

    function rand(min, max){ return Math.random() * (max - min) + min; }

    class Particle {
      constructor(){
        this.reset(true);
      }
      reset(init=false){
        this.x = rand(0, w);
        this.y = rand(0, h);
        this.vx = rand(-0.3, 0.3);
        this.vy = rand(-0.3, 0.3);
        this.r = rand(1.2, 3.2);
        this.baseR = this.r;
        this.hue = rand(180, 260); // bluish/purple
        this.alpha = rand(0.25, 0.9);
        if(!init && Math.random() < 0.02){ // small chance to respawn near mouse
          this.x = mouse.x + rand(-30,30);
          this.y = mouse.y + rand(-30,30);
        }
      }
      update(){
        // gentle movement
        this.x += this.vx;
        this.y += this.vy;

        // wrap edges
        if(this.x < -10) this.x = w + 10;
        if(this.x > w + 10) this.x = -10;
        if(this.y < -10) this.y = h + 10;
        if(this.y > h + 10) this.y = -10;

        // repel from mouse
        const dx = this.x - mouse.x;
        const dy = this.y - mouse.y;
        const d2 = dx*dx + dy*dy;
        const minDist = (mouse.r + this.r) * (mouse.r + this.r);
        if(d2 < minDist){
          const dist = Math.sqrt(d2) || 0.001;
          const force = (mouse.r - dist) / mouse.r;
          const nx = dx / dist;
          const ny = dy / dist;
          this.vx += nx * force * 0.8;
          this.vy += ny * force * 0.8;
          // grow a little when close
          this.r = Math.min(this.baseR * 2.6, this.r + force * 0.8);
        } else {
          // slowly return size
          this.r += (this.baseR - this.r) * 0.05;
          // gentle damping to avoid runaway speeds
          this.vx *= 0.995;
          this.vy *= 0.995;
        }

        // if mouse clicked, boost
        if(mouse.down){
          this.vx += rand(-0.12,0.12);
          this.vy += rand(-0.12,0.12);
        }
      }
      draw(){
        ctx.beginPath();
        ctx.fillStyle = `hsla(${this.hue}, 85%, 60%, ${this.alpha})`;
        ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // create particles
    for(let i=0; i<particleCount; i++) particles.push(new Particle());

    function connectParticles(){
      // draw soft lines between nearby particles
      for(let i=0; i<particles.length; i++){
        const p = particles[i];
        for(let j=i+1; j<particles.length; j++){
          const q = particles[j];
          const dx = p.x - q.x;
          const dy = p.y - q.y;
          const d = Math.sqrt(dx*dx + dy*dy);
          if(d < 110){
            const t = 1 - (d / 110);
            ctx.beginPath();
            ctx.strokeStyle = `rgba(150,180,255,${0.06 + 0.18 * t})`;
            ctx.lineWidth = 1 * t;
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(q.x, q.y);
            ctx.stroke();
          }
        }
      }
    }

    function animate(){
      ctx.clearRect(0,0,w,h);
      // subtle background gradient (drawn on canvas for harmony)
      const g = ctx.createLinearGradient(0,0,w,h);
      g.addColorStop(0, 'rgba(10,15,25,0.15)');
      g.addColorStop(1, 'rgba(20,10,35,0.12)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);

      // update & draw particles
      for(const p of particles){
        p.update();
        p.draw();
      }

      // connect
      connectParticles();

      requestAnimationFrame(animate);
    }

    // small performance guard: reduce particles on low-power devices
    if(navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 2){
      while(particles.length > Math.round((w * h) / 120000)){
        particles.pop();
      }
    }

    animate();
  </script>
</body>
</html>
